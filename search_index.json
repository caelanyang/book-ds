[
["index.html", "数据结构系列文章 Chapter 1 Prerequisites", " 数据结构系列文章 Jiacheng 2019-03-27 Chapter 1 Prerequisites This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports, e.g., a math equation \\(a^2 + b^2 = c^2\\). The bookdown package can be installed from CRAN or Github: install.packages(&quot;bookdown&quot;) Remember each Rmd file contains one and only one chapter, and a chapter is defined by the first-level heading #. To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.name/tinytex/. "],
["3c7370616e20636c6173733d226865616465722d73656374696f6e2d6e756d626572223e323c2f7370616e3e20e993bee8a1a83c2f68313e200a3c2f6469763e.html", "Chapter 2 链表 ", " Chapter 2 链表 "],
["section-2-1.html", "2.1 引言", " 2.1 引言 与数组一样，链表也是一种线性数据结构。 与数组不同，链表元素的存储空间是不连续的；元素之间使用指针链接，即前一个元素使用指针（后继指针 next）保存下一个元素的地址。链表元素与指针共同成为链表的节点（Node） 2.1.1 为什么要用链表? 数组可以用来存储类似类型的线性数据，但是数组有以下局限： 数组的大小是固定的：所以必须先确定元素数量的上限。 而且，通常情况下，无论需要使用的空间是多大，数组分配的内存大小都等于元素数量上限，而与使用情况无关。 在一个数组中插入一个新元素开销很大，因为需要为新元素创建空间，新元素后面的所有已存在的元素必须进行移位。 例如，在一个系统中， id [] 中保存一个已排序的 ID 数组： id[] = [1000, 1010, 1050, 2000, 2040] 如果我们想插入一个新的 ID 1005，同时保持数组已排序，我们必须移动1000之后的所有元素(不包括1000)。 在不使用某些特殊技术得情况下，删除元素的开销也很大。 例如，要删除 id []中的1010，1010之后的所有内容都必须移动。 2.1.2 链表的优点 动态大小 易于插入 / 删除 2.1.3 链表的缺点 不允许随机访问。 必须从第一个节点开始顺序地访问元素。 因此我们不能使用二分搜索的默认实现对链表进行查找。 点击这里阅读。 每个节点的后继指针都需要消耗额外的内存空间 CPU 缓存不友好。 由于数组使用连续的内存空间，借助 CPU 的缓存机制1，预读数组中的数据，提高访问效率。而链表的存储空间是不连续的，对 CPU 缓存不友好。 2.1.4 链表的表示形式 链表由指向链表第一个节点的指针表示。 第一个节点称为链表的头。 如果链表为空，那么 head 的值为 NULL。 列表中的每个节点至少由两部分组成: 1. 数据 2. 指向下一个节点的指针(或引用) 在 c 中，可以使用结构体表示一个节点。 下面是一个带有整数数据的链表节点的示例。 在 Java 或 Python 中，LinkedList 可以表示为一个类，而 Node 可以表示为一个单独的类。 LinkedList 类包含一个 Node 类型的引用。 Python 代码示例： class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None 使用以上两个类创建一个有三个元素的链表： def main(): linked_list = LinkedList() linked_list.head = Node(1) second_node = Node(2) third_node = Node(3) linked_list.head.next = second_node second_node.next = third_node 2.1.5 链表的遍历 遍历上面已创建的 linked_list def print_list(linked_list): temp = linked_list.head while temp: print(temp.data) temp = temp.next 局部性原理 Locality of Reference：处理器访问存储器时，无论是读取指令还是存取数据，所访问的存储单元在一段时间内都趋向于一个较小的连续区域中。空间局部（Spatial locality）：紧邻被访问单元的地方也将被访问。 时间局部（Temporal locality）：刚被访问的单元很快将再次被访问。↩ "],
["literature.html", "Chapter 3 Literature", " Chapter 3 Literature Here is a review of existing methods. "],
["methods.html", "Chapter 4 Methods", " Chapter 4 Methods We describe our methods in this chapter. "],
["applications.html", "Chapter 5 Applications", " Chapter 5 Applications Some significant applications are demonstrated in this chapter. "],
["example-one.html", "5.1 Example one", " 5.1 Example one "],
["example-two.html", "5.2 Example two", " 5.2 Example two "],
["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
